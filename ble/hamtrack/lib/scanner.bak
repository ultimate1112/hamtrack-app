import 'package:flutter/material.dart';
import 'dart:async';
import 'dart:math';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'dart:io';

import 'package:flutter_blue/flutter_blue.dart';
import 'ble_settings.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'dart:typed_data';

int byteToInt8(int b) =>
    new Uint8List.fromList([b]).buffer.asByteData().getInt8(0);

int twoByteToInt16(int v1, int v2) =>
    new Uint8List.fromList([v1, v2]).buffer.asByteData().getUint16(0);

String byteListToHexString(List<int> bytes) => bytes
    .map((i) => i.toRadixString(16).padLeft(2, '0'))
    .reduce((a, b) => (a + b));

/// Model of a BLE Device.
class BLEDevice {
  //TODO:Add major and minor.
  String addr;
  int rssi;
  int major;
  int minor;

  BLEDevice({this.addr="", this.rssi=0});

  Map<String, dynamic> toJson() => {
    'addr': this.addr,
    'rssi': this.rssi.toString(),
    'major': this.major.toString(),
    'minor': this.minor.toString(),
  };

}

class BLEData {
  String timestamp;
  List<BLEDevice> data;

  BLEData({timestamp,data}) {
    this.timestamp = timestamp ?? '';
    this.data = data ?? List<BLEDevice>();
  }

  Map<String, dynamic> toJSON() {
    List<Map> dataJson = (this.data == null) ? null : this.data.map((e) => e.toJson()).toList();
    return {
      'timestamp': this.timestamp,
      'data': dataJson,
    };
  }
}

/// BLE Scanner class.
class Scanner {
  bool isEnabled = false;
  bool scanLock = false;

  BLESettingsModel model = BLESettingsModel();                                          // Input Parameters.
  Timer autoScanTimer = Timer(Duration(seconds:0), () => {});                           // autoScan Periodic Timer.
  List<ScanResult> rawData = List<ScanResult>();                                       // Raw BLE Scan Data.
  DateTime scanTime = DateTime.now();                                                   // Timestamp of scan.
  StreamController<BLEData> controller = StreamController<BLEData>();   // Output Stream Controller.
  BLEData scanData = BLEData();

Scanner() {

}

  /// Get stream.
  getStream() {
    return controller.stream;
  }

  // Enable autoScan.
  Future<void> enable() async {
    isEnabled = true;
    await refresh();
  }

  /// Disable autoScan.
  Future<void> disable() async {
    isEnabled = false;
    await refresh();
  }

  /// Refresh with new parameters.
  Future<void> refresh() async {
    await model.loadModel();  // Pre-emptively load model.
    autoScanTimer.cancel();
    await startScan(callback: true);
  }

  /// Endpoint to start scan.
  /// If callback is true, will only run if model.autoScan is enabled.
  Future<void> startScan({callback=false}) async {

    if(!await model.verifyModel()) {
      // Parameters have changed.
      // model.verifyModel will fix internal issues.
      await startScan(callback: callback);   // Recall process.
      return;
    }

    if(!isEnabled) {
      // BLE is not enabled.
      autoScanTimer.cancel();
      return;
    }

    if(callback && !model.autoScan) {
      // AutoScan is not enabled. Skip if executed manually.
      autoScanTimer.cancel();
      return;
    }

    if(model.autoScan && (autoScanTimer == null || !autoScanTimer.isActive)) {
      // Timer is not active. Reactivate.
      autoScanTimer = Timer.periodic(
          Duration(seconds: model.autoScanDuration),
          (t) => {startScan(callback: true)});
      // Continue, and run immediately.
    }

    // Execute BLE scan.
    await scan();
  }


  /// Scan.
  Future<void> scan() async {
    if(!await queryBLE()) {
      return;
    }
    processBLE();
    if(!await sendToServer()) {
      Fluttertoast.showToast(
          msg: "Failed to send to server.",
          toastLength: Toast.LENGTH_SHORT,
          gravity: ToastGravity.BOTTOM,
          timeInSecForIosWeb: 1,
          backgroundColor: Colors.red,
          textColor: Colors.white,
          fontSize: 16.0
      );
      return;
    }

  }

  /// Perform a BLE query.
  /// returns false if could not scan, true if successfully scanned.
  Future<bool> queryBLE() async {
    if(scanLock) {
      // Existing scan is already running. Skip.
      print('SKIPPPPPPPPPPPPPPPPPPPPPPPPP');
      return false;   // Unable to scan.
    }
    scanLock = true;  // Lock.

    // Initialize required variables.
    final FlutterBlue flutterBlue = FlutterBlue.instance;
    scanTime = new DateTime.now();

    // Start Scan. Will stop scan after timeout.
    Future scanResult = flutterBlue.startScan(
        scanMode: ScanMode.lowLatency,
        timeout: Duration(seconds: 2));

    // Collect Results.
    rawData = await scanResult;

    scanLock = false; // Unlock
    return true;      // Successfully scanned.
  } /* END: queryBLE */

  bool processBLE() {
    scanData = new BLEData();

    scanData.timestamp = scanTime.toString(); // Timestamp of Data.
    scanData.data = new List<BLEDevice>();    // BLE Data.
    BLEDevice dev;
    for(ScanResult r in rawData) {
      dev = new BLEDevice();
      dev.addr = r.device.id.toString();
      dev.rssi = r.rssi;
//TODO: Build data from here.

      if(
r.advertisementData.manufacturerData.containsKey(0x004C)
&& r.advertisementData.manufacturerData[0x004C].length >= 23
&& (r.advertisementData.manufacturerData[0x004C][0] == 0x02 || r.advertisementData.manufacturerData[0x004C][1] == 0x15)
      ) {
        List<int> rawBytes = r.advertisementData.manufacturerData[0x004C];
        //dev.uuid = byteListToHexString(rawBytes.sublist(2, 18));
        dev.major = twoByteToInt16(rawBytes[18], rawBytes[19]);
        dev.minor = twoByteToInt16(rawBytes[20], rawBytes[21]);
      }

      scanData.data.add(dev);
    }
    scanData.data.sort((a, b) => a.rssi.compareTo(b.rssi)); // Sort by rssi.

    controller.add(scanData);
    return true;
  }

  Future<bool> sendToServer() async {

    // Process scanData into timestamp & string payload.
    List<Map> dataJson = (scanData.data == null) ? null : scanData.data.map((e) => e.toJson()).toList();
    var data = {
      'tracker': model.devId,
      'timestamp': scanData.timestamp,
      'count': scanData.data.length.toString(),
      'payload': jsonEncode(dataJson),
    };

    // Send POST packet to server.
    http.Response response = await http.post(model.url, body: data);

    // Check if request was successful.
    if(response.statusCode != 200) {
      print("Error sending to server. [HTTP Code "+ response.statusCode.toString() +"]");
      return false;
    }

    return true;
  }


}